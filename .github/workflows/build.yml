name: Build and Package

# 缓存策略说明:
# 1. Rust工具链和组件缓存 - 跨job共享
# 2. Cargo依赖缓存 - 基于Cargo.lock哈希
# 3. NDK缓存 - 避免重复下载大文件
# 4. 系统依赖缓存 - 避免重复apt安装
# 5. 工具二进制缓存 - cargo-ndk, shfmt等

on:
  pull_request:
    branches: [ master ]
  workflow_dispatch:
    inputs:
      build_type:
        description: 'Build type (debug, release, both, or cleanup)'
        required: true
        default: 'both'
        type: choice
        options:
        - debug
        - release
        - both
        - cleanup

env:
  CARGO_TERM_COLOR: always

jobs:
  format-and-check:
    name: Format and Lint Check
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        submodules: recursive

    - name: System diagnostics
      run: |
        echo "🔍 System Information:"
        echo "Disk space: $(df -h / | tail -1)"
        echo "Memory: $(free -h | grep Mem)"
        echo "Available space for /tmp: $(df -h /tmp | tail -1)"
        echo "Runner temp: $RUNNER_TEMP"
      
    - name: Setup Rust
      uses: dtolnay/rust-toolchain@stable
      with:
        components: rustfmt, clippy

    - name: Cache Rust toolchain and tools
      uses: actions/cache@v4
      with:
        path: |
          ~/.rustup
          ~/.cargo/bin
        key: ${{ runner.os }}-rust-toolchain-${{ hashFiles('rust-toolchain.toml', 'Cargo.toml') }}
        restore-keys: |
          ${{ runner.os }}-rust-toolchain-

    - name: Setup Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.x'

    - name: Cache Python packages
      uses: actions/cache@v4
      with:
        path: ~/.cache/pip
        key: ${{ runner.os }}-pip-${{ hashFiles('**/requirements*.txt') }}
        restore-keys: |
          ${{ runner.os }}-pip-
        
    - name: Cache shfmt binary
      uses: actions/cache@v4
      id: cache-shfmt
      with:
        path: ~/.local/bin/shfmt
        key: ${{ runner.os }}-shfmt-v3.7.0

    - name: Install shfmt
      if: steps.cache-shfmt.outputs.cache-hit != 'true'
      run: |
        # 使用更简单和可靠的方法安装 shfmt 到用户目录
        SHFMT_VERSION="v3.7.0"
        mkdir -p ~/.local/bin
        wget -O ~/.local/bin/shfmt "https://github.com/mvdan/sh/releases/download/${SHFMT_VERSION}/shfmt_${SHFMT_VERSION}_linux_amd64"
        chmod +x ~/.local/bin/shfmt
        echo "$HOME/.local/bin" >> $GITHUB_PATH
        
    - name: Format shell scripts
      run: |
        find module -type f -name "*.sh" -exec shfmt -w -s {} \;
        
    - name: Format Python code
      run: |
        python -m pip install --upgrade pip black isort
        black --check build.py
        isort --check-only build.py
        
    - name: Format Rust code
      run: cargo fmt --check
      
    - name: Run clippy
      run: cargo clippy -- -D warnings

  version-sync:
    name: Version Synchronization Check
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        submodules: recursive
        
    - name: Check version consistency
      run: |
        # Check if module.prop exists
        if [ ! -f "module/module.prop" ]; then
          echo "❌ module/module.prop not found!"
          echo "Available files in module directory:"
          ls -la module/ || echo "module directory not found"
          exit 1
        fi
        
        CARGO_VERSION=$(grep '^version = ' Cargo.toml | sed 's/version = "//' | sed 's/"//')
        MODULE_VERSION=$(grep '^version=' module/module.prop | sed 's/version=v//')
        
        echo "📦 Cargo.toml version: $CARGO_VERSION"
        echo "📱 module.prop version: $MODULE_VERSION"
        
        if [ "$CARGO_VERSION" != "$MODULE_VERSION" ]; then
          echo ""
          echo "⚠️  Version mismatch detected!"
          echo "   Cargo.toml: $CARGO_VERSION"
          echo "   module.prop: v$MODULE_VERSION"
          echo ""
          echo "💡 To fix this, update module/module.prop:"
          echo "   version=v$CARGO_VERSION"
          echo ""
          echo "🔧 Or run this command locally:"
          echo "   sed -i 's/version=v.*/version=v$CARGO_VERSION/' module/module.prop"
          exit 1
        else
          echo "✅ Versions are synchronized: v$CARGO_VERSION"
        fi

  test:
    name: Run Tests
    runs-on: ubuntu-latest
    if: github.event_name != 'workflow_dispatch' || github.event.inputs.build_type != ''
    
    # 添加超时限制
    timeout-minutes: 30
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        submodules: recursive
      
    - name: Setup Rust
      uses: dtolnay/rust-toolchain@stable
      with:
        targets: aarch64-linux-android

    - name: Cache Rust toolchain
      uses: actions/cache@v4
      with:
        path: |
          ~/.rustup
          ~/.cargo/bin
        key: ${{ runner.os }}-rust-toolchain-test-${{ hashFiles('rust-toolchain.toml', 'Cargo.toml') }}
        restore-keys: |
          ${{ runner.os }}-rust-toolchain-
        
    - name: Setup Android NDK
      uses: nttld/setup-ndk@v1
      id: setup-ndk
      with:
        ndk-version: r28b

    # 暂时禁用 NDK 缓存避免大小限制问题 - Test Job
    # - name: Cache NDK
    #   uses: actions/cache@v4
    #   with:
    #     path: ${{ steps.setup-ndk.outputs.ndk-path }}
    #     key: ${{ runner.os }}-ndk-r28b
    #     restore-keys: |
    #       ${{ runner.os }}-ndk-

    - name: Install system dependencies for bindgen (always install for reliability)
      run: |
        echo "📦 Installing bindgen dependencies for test job..."
        
        # 更新包列表
        sudo apt-get update -qq
        
        # 安装必需的clang和libclang依赖
        sudo apt-get install -y --no-install-recommends \
          clang-15 \
          libclang-15-dev \
          llvm-15-dev \
          clang \
          libclang-dev \
          llvm-dev
        
        # 创建多个版本的符号链接以确保兼容性
        sudo ln -sf /usr/bin/clang-15 /usr/local/bin/clang || true
        sudo ln -sf /usr/bin/clang /usr/local/bin/clang || true
        
        # 查找并设置libclang路径
        for libclang_path in /usr/lib/llvm-15/lib /usr/lib/llvm-14/lib /usr/lib/x86_64-linux-gnu; do
          if [ -f "$libclang_path/libclang.so.1" ] || [ -f "$libclang_path/libclang.so" ]; then
            sudo ln -sf "$libclang_path/libclang.so"* /usr/local/lib/libclang.so || true
            echo "Found libclang at: $libclang_path"
            break
          fi
        done
        
        echo "✅ Bindgen dependencies installed for test"
        
    - name: Setup libclang environment for tests
      run: |
        # 查找可用的libclang路径
        FOUND_LIBCLANG_PATH=""
        for path in /usr/lib/llvm-15/lib /usr/lib/llvm-14/lib /usr/lib/x86_64-linux-gnu; do
          if [ -f "$path/libclang.so.1" ] || [ -f "$path/libclang.so" ]; then
            FOUND_LIBCLANG_PATH="$path"
            echo "Found libclang at: $path"
            break
          fi
        done
        
        if [ -z "$FOUND_LIBCLANG_PATH" ]; then
          echo "❌ libclang not found in expected locations"
          echo "Searching for libclang in system..."
          find /usr -name "libclang.so*" 2>/dev/null | head -5
          exit 1
        fi
        
        # 设置环境变量
        echo "LIBCLANG_PATH=$FOUND_LIBCLANG_PATH" >> $GITHUB_ENV
        echo "CLANG_PATH=/usr/bin/clang" >> $GITHUB_ENV
        
        # 查找clang include路径
        CLANG_INCLUDE_PATH=""
        for path in /usr/lib/llvm-15/lib/clang/15.*/include /usr/lib/llvm-14/lib/clang/14.*/include /usr/lib/clang/*/include; do
          if [ -d "$path" ]; then
            CLANG_INCLUDE_PATH="$path"
            break
          fi
        done
        
        if [ -n "$CLANG_INCLUDE_PATH" ]; then
          echo "BINDGEN_EXTRA_CLANG_ARGS=-I$CLANG_INCLUDE_PATH" >> $GITHUB_ENV
        fi
        
        echo "🔍 Test libclang environment:"
        echo "LIBCLANG_PATH: $FOUND_LIBCLANG_PATH"
        echo "CLANG_PATH: /usr/bin/clang"
        echo "CLANG_INCLUDE_PATH: $CLANG_INCLUDE_PATH"
        
        # 验证clang工作正常
        clang --version | head -1

    - name: Create Linux-specific Cargo config for tests
      run: |
        # 创建专门用于 Linux CI 的 cargo 配置
        mkdir -p .cargo
        cat > .cargo/config-linux.toml << 'EOF'
        [env]
        # 设置 bindgen 使用的 libclang 路径（从环境变量中读取）
        LIBCLANG_PATH = { value = "$LIBCLANG_PATH", relative = false }
        
        # 设置 clang 可执行文件路径
        CLANG_PATH = { value = "/usr/bin/clang", relative = false }
        
        [target.aarch64-linux-android]
        linker = "aarch64-linux-android33-clang"
        
        [build]
        target = "aarch64-linux-android"
        EOF
        
        # 备份原有的配置文件
        if [ -f ".cargo/config.toml" ]; then
          mv .cargo/config.toml .cargo/config-windows.toml
        fi
        
        # 使用 Linux 配置
        mv .cargo/config-linux.toml .cargo/config.toml
        
        echo "✅ Created Linux-specific Cargo configuration for tests"
        cat .cargo/config.toml
        
    - name: Cache cargo-ndk for tests
      uses: actions/cache@v4
      id: cache-cargo-ndk-test
      with:
        path: ~/.cargo/bin/cargo-ndk
        key: ${{ runner.os }}-cargo-ndk-test-${{ hashFiles('Cargo.toml') }}
        
    - name: Install cargo-ndk for tests
      if: steps.cache-cargo-ndk-test.outputs.cache-hit != 'true'
      run: cargo install cargo-ndk --force
        
    - name: Cache cargo dependencies
      uses: actions/cache@v4
      with:
        path: |
          ~/.cargo/registry
          ~/.cargo/git
        key: ${{ runner.os }}-test-cargo-deps-${{ hashFiles('**/Cargo.lock') }}
        restore-keys: |
          ${{ runner.os }}-test-cargo-deps-
          ${{ runner.os }}-cargo-deps-

    - name: Clean target directory (avoid cache size issues)
      run: |
        # Remove old target files to prevent cache bloat
        if [ -d "target" ]; then
          find target -name "*.rlib" -type f -delete 2>/dev/null || true
          find target -name "*.rmeta" -type f -delete 2>/dev/null || true
          find target -name "incremental" -type d -exec rm -rf {} + 2>/dev/null || true
          echo "🧹 Cleaned target directory"
        fi
          
    - name: Run tests
      env:
        ANDROID_NDK_HOME: ${{ steps.setup-ndk.outputs.ndk-path }}
        ANDROID_NDK_ROOT: ${{ steps.setup-ndk.outputs.ndk-path }}
        NDK_HOME: ${{ steps.setup-ndk.outputs.ndk-path }}
        CC_aarch64_linux_android: ${{ steps.setup-ndk.outputs.ndk-path }}/toolchains/llvm/prebuilt/linux-x86_64/bin/aarch64-linux-android33-clang
        CXX_aarch64_linux_android: ${{ steps.setup-ndk.outputs.ndk-path }}/toolchains/llvm/prebuilt/linux-x86_64/bin/aarch64-linux-android33-clang++
        AR_aarch64_linux_android: ${{ steps.setup-ndk.outputs.ndk-path }}/toolchains/llvm/prebuilt/linux-x86_64/bin/llvm-ar
        RANLIB_aarch64_linux_android: ${{ steps.setup-ndk.outputs.ndk-path }}/toolchains/llvm/prebuilt/linux-x86_64/bin/llvm-ranlib
        CARGO_TARGET_AARCH64_LINUX_ANDROID_LINKER: ${{ steps.setup-ndk.outputs.ndk-path }}/toolchains/llvm/prebuilt/linux-x86_64/bin/aarch64-linux-android33-clang
        RUST_LOG: debug
      run: |
        echo "🔍 Test environment verification:"
        echo "NDK Path: $ANDROID_NDK_HOME"
        echo "LibClang Path: $LIBCLANG_PATH"
        echo "Clang Path: $CLANG_PATH"
        
        # 验证必需的环境变量
        if [ -z "$LIBCLANG_PATH" ]; then
          echo "❌ LIBCLANG_PATH not set!"
          exit 1
        fi
        
        if [ ! -f "$LIBCLANG_PATH/libclang.so.1" ] && [ ! -f "$LIBCLANG_PATH/libclang.so" ]; then
          echo "❌ libclang not found at $LIBCLANG_PATH"
          echo "Available files:"
          ls -la "$LIBCLANG_PATH/" | grep clang || echo "No clang files found"
          exit 1
        fi
        
        # 设置Android相关的bindgen参数
        export BINDGEN_EXTRA_CLANG_ARGS="--target=aarch64-linux-android33 --sysroot=${{ steps.setup-ndk.outputs.ndk-path }}/toolchains/llvm/prebuilt/linux-x86_64/sysroot -I${{ steps.setup-ndk.outputs.ndk-path }}/toolchains/llvm/prebuilt/linux-x86_64/sysroot/usr/include -I${{ steps.setup-ndk.outputs.ndk-path }}/toolchains/llvm/prebuilt/linux-x86_64/sysroot/usr/include/aarch64-linux-android $BINDGEN_EXTRA_CLANG_ARGS"
        
        clang --version | head -1
        
        # 验证NDK工具（仅第一次）
        if [ ! -f ~/.cache/ndk-verified ]; then
          echo "🛠️ NDK tools verification:"
          ls -la "$ANDROID_NDK_HOME/toolchains/llvm/prebuilt/linux-x86_64/bin/" | grep aarch64 | head -2
          mkdir -p ~/.cache && touch ~/.cache/ndk-verified
        fi
        
        # First, verify that the code compiles for Android target
        echo "🔧 Checking Android target compilation..."
        cargo ndk --target aarch64-linux-android --platform 33 check --verbose
        
        # Run unit tests (this project is a binary, so we test the binary)
        echo "🧪 Running unit tests..."
        cargo ndk --target aarch64-linux-android --platform 33 test --verbose --no-run
        
        echo "✅ Android target compilation and test compilation successful"

  build-debug:
    name: Build Module (debug)
    runs-on: ubuntu-latest
    needs: [format-and-check, version-sync, test]
    if: github.event_name != 'workflow_dispatch' || github.event.inputs.build_type == 'debug' || github.event.inputs.build_type == 'both' || github.event.inputs.build_type == ''

    # 添加超时限制，防止缓存问题导致的无限等待
    timeout-minutes: 45
        
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        submodules: recursive
        
    - name: Setup Rust
      uses: dtolnay/rust-toolchain@stable
      with:
        targets: aarch64-linux-android

    - name: Cache Rust toolchain
      uses: actions/cache@v4
      with:
        path: |
          ~/.rustup
          ~/.cargo/bin
        key: ${{ runner.os }}-rust-toolchain-build-${{ hashFiles('rust-toolchain.toml', 'Cargo.toml') }}
        restore-keys: |
          ${{ runner.os }}-rust-toolchain-

    - name: Cache cargo-ndk
      uses: actions/cache@v4
      id: cache-cargo-ndk-build
      with:
        path: ~/.cargo/bin/cargo-ndk
        key: ${{ runner.os }}-cargo-ndk-${{ hashFiles('Cargo.toml') }}
        
    - name: Install cargo-ndk
      if: steps.cache-cargo-ndk-build.outputs.cache-hit != 'true'
      run: cargo install cargo-ndk --force

    - name: Install system dependencies for bindgen (always install for reliability)
      run: |
        echo "📦 Installing bindgen dependencies for debug build job..."
        
        # 更新包列表
        sudo apt-get update -qq
        
        # 安装必需的clang和libclang依赖
        sudo apt-get install -y --no-install-recommends \
          clang-15 \
          libclang-15-dev \
          llvm-15-dev \
          clang \
          libclang-dev \
          llvm-dev
        
        # 创建多个版本的符号链接以确保兼容性
        sudo ln -sf /usr/bin/clang-15 /usr/local/bin/clang || true
        sudo ln -sf /usr/bin/clang /usr/local/bin/clang || true
        
        # 查找并设置libclang路径
        for libclang_path in /usr/lib/llvm-15/lib /usr/lib/llvm-14/lib /usr/lib/x86_64-linux-gnu; do
          if [ -f "$libclang_path/libclang.so.1" ] || [ -f "$libclang_path/libclang.so" ]; then
            sudo ln -sf "$libclang_path/libclang.so"* /usr/local/lib/libclang.so || true
            echo "Found libclang at: $libclang_path"
            break
          fi
        done
        
        echo "✅ Bindgen dependencies installed for debug build"

    - name: Setup libclang environment for debug build
      run: |
        # 查找可用的libclang路径
        FOUND_LIBCLANG_PATH=""
        for path in /usr/lib/llvm-15/lib /usr/lib/llvm-14/lib /usr/lib/x86_64-linux-gnu; do
          if [ -f "$path/libclang.so.1" ] || [ -f "$path/libclang.so" ]; then
            FOUND_LIBCLANG_PATH="$path"
            echo "Found libclang at: $path"
            break
          fi
        done
        
        if [ -z "$FOUND_LIBCLANG_PATH" ]; then
          echo "❌ libclang not found in expected locations"
          echo "Searching for libclang in system..."
          find /usr -name "libclang.so*" 2>/dev/null | head -5
          exit 1
        fi
        
        # 设置环境变量
        echo "LIBCLANG_PATH=$FOUND_LIBCLANG_PATH" >> $GITHUB_ENV
        echo "CLANG_PATH=/usr/bin/clang" >> $GITHUB_ENV
        
        # 查找clang include路径
        CLANG_INCLUDE_PATH=""
        for path in /usr/lib/llvm-15/lib/clang/15.*/include /usr/lib/llvm-14/lib/clang/14.*/include /usr/lib/clang/*/include; do
          if [ -d "$path" ]; then
            CLANG_INCLUDE_PATH="$path"
            break
          fi
        done
        
        if [ -n "$CLANG_INCLUDE_PATH" ]; then
          echo "BINDGEN_EXTRA_CLANG_ARGS=-I$CLANG_INCLUDE_PATH" >> $GITHUB_ENV
        fi
        
        echo "🔍 Debug build libclang environment:"
        echo "LIBCLANG_PATH: $FOUND_LIBCLANG_PATH"
        echo "CLANG_PATH: /usr/bin/clang"
        echo "CLANG_INCLUDE_PATH: $CLANG_INCLUDE_PATH"
        
        # 验证clang工作正常
        clang --version | head -1

    - name: Create Linux-specific Cargo config for debug build
      run: |
        # 创建专门用于 Linux CI 的 cargo 配置
        mkdir -p .cargo
        cat > .cargo/config-linux.toml << 'EOF'
        [env]
        # 设置 bindgen 使用的 libclang 路径（从环境变量中读取）
        LIBCLANG_PATH = { value = "$LIBCLANG_PATH", relative = false }
        
        # 设置 clang 可执行文件路径
        CLANG_PATH = { value = "/usr/bin/clang", relative = false }
        
        [target.aarch64-linux-android]
        linker = "aarch64-linux-android33-clang"
        
        [build]
        target = "aarch64-linux-android"
        EOF
        
        # 备份原有的配置文件
        if [ -f ".cargo/config.toml" ]; then
          mv .cargo/config.toml .cargo/config-windows.toml
        fi
        
        # 使用 Linux 配置
        mv .cargo/config-linux.toml .cargo/config.toml
        
        echo "✅ Created Linux-specific Cargo configuration"
        cat .cargo/config.toml
        
    - name: Setup Android NDK
      uses: nttld/setup-ndk@v1
      id: setup-ndk
      with:
        ndk-version: r28b

    # NDK 缓存暂时禁用以避免 GitHub Actions 缓存大小限制
    # - name: Cache NDK
    #   uses: actions/cache@v4
    #   with:
    #     path: ${{ steps.setup-ndk.outputs.ndk-path }}
    #     key: ${{ runner.os }}-ndk-r28b
    #     restore-keys: |
    #       ${{ runner.os }}-ndk-

    - name: Cache cargo dependencies (debug)
      uses: actions/cache@v4
      with:
        path: |
          ~/.cargo/registry
          ~/.cargo/git
        key: ${{ runner.os }}-build-debug-cargo-deps-${{ hashFiles('**/Cargo.lock') }}
        restore-keys: |
          ${{ runner.os }}-build-cargo-deps-
          ${{ runner.os }}-cargo-deps-

    - name: Clean target directory (avoid cache size issues)
      run: |
        # Remove old target files to prevent cache bloat
        if [ -d "target" ]; then
          find target -name "*.rlib" -type f -delete 2>/dev/null || true
          find target -name "*.rmeta" -type f -delete 2>/dev/null || true
          find target -name "incremental" -type d -exec rm -rf {} + 2>/dev/null || true
          echo "🧹 Cleaned target directory"
        fi
          
    - name: Build debug version
      env:
        ANDROID_NDK_HOME: ${{ steps.setup-ndk.outputs.ndk-path }}
        ANDROID_NDK_ROOT: ${{ steps.setup-ndk.outputs.ndk-path }}
        NDK_HOME: ${{ steps.setup-ndk.outputs.ndk-path }}
        CC_aarch64_linux_android: ${{ steps.setup-ndk.outputs.ndk-path }}/toolchains/llvm/prebuilt/linux-x86_64/bin/aarch64-linux-android33-clang
        CXX_aarch64_linux_android: ${{ steps.setup-ndk.outputs.ndk-path }}/toolchains/llvm/prebuilt/linux-x86_64/bin/aarch64-linux-android33-clang++
        AR_aarch64_linux_android: ${{ steps.setup-ndk.outputs.ndk-path }}/toolchains/llvm/prebuilt/linux-x86_64/bin/llvm-ar
        RANLIB_aarch64_linux_android: ${{ steps.setup-ndk.outputs.ndk-path }}/toolchains/llvm/prebuilt/linux-x86_64/bin/llvm-ranlib
        CARGO_TARGET_AARCH64_LINUX_ANDROID_LINKER: ${{ steps.setup-ndk.outputs.ndk-path }}/toolchains/llvm/prebuilt/linux-x86_64/bin/aarch64-linux-android33-clang
      run: |
        echo "🔍 Debug build environment verification:"
        echo "NDK Path: $ANDROID_NDK_HOME"
        echo "LibClang Path: $LIBCLANG_PATH"
        echo "Clang Path: $CLANG_PATH"
        
        # 验证必需的环境变量
        if [ -z "$LIBCLANG_PATH" ]; then
          echo "❌ LIBCLANG_PATH not set!"
          exit 1
        fi
        
        if [ ! -f "$LIBCLANG_PATH/libclang.so.1" ] && [ ! -f "$LIBCLANG_PATH/libclang.so" ]; then
          echo "❌ libclang not found at $LIBCLANG_PATH"
          echo "Available files:"
          ls -la "$LIBCLANG_PATH/" | grep clang || echo "No clang files found"
          exit 1
        fi
        
        # 设置Android相关的bindgen参数
        export BINDGEN_EXTRA_CLANG_ARGS="--target=aarch64-linux-android33 --sysroot=${{ steps.setup-ndk.outputs.ndk-path }}/toolchains/llvm/prebuilt/linux-x86_64/sysroot -I${{ steps.setup-ndk.outputs.ndk-path }}/toolchains/llvm/prebuilt/linux-x86_64/sysroot/usr/include -I${{ steps.setup-ndk.outputs.ndk-path }}/toolchains/llvm/prebuilt/linux-x86_64/sysroot/usr/include/aarch64-linux-android $BINDGEN_EXTRA_CLANG_ARGS"
        
        clang --version | head -1
        
        cargo ndk -t arm64-v8a build --target aarch64-linux-android
        
        # Verify build success
        if [ ! -f "target/aarch64-linux-android/debug/gpugovernor" ]; then
          echo "❌ Build failed - output binary not found"
          echo "📁 Checking target directory structure:"
          find target -name "gpugovernor" -type f 2>/dev/null || echo "No gpugovernor binary found anywhere"
          exit 1
        fi
        
        echo "✅ Debug build completed successfully"
        ls -la target/aarch64-linux-android/debug/gpugovernor
        
    - name: Package debug module
      run: |
        # Pre-flight checks
        echo "🔍 Pre-flight checks:"
        echo "module directory exists: $(test -d module && echo 'YES' || echo 'NO')"
        echo "module/bin directory exists: $(test -d module/bin && echo 'YES' || echo 'NO')"
        
        if [ ! -d "module" ]; then
          echo "❌ Error: module directory not found!"
          ls -la
          exit 1
        fi
        
        if [ ! -d "module/bin" ]; then
          echo "❌ Error: module/bin directory not found!"
          ls -la module/
          exit 1
        fi
        
        # Create output directory
        mkdir -p output
        
        # Verify the build output exists
        if [ ! -f "target/aarch64-linux-android/debug/gpugovernor" ]; then
          echo "❌ Build output not found: target/aarch64-linux-android/debug/gpugovernor"
          echo "📁 Available files in target/aarch64-linux-android/debug/:"
          ls -la target/aarch64-linux-android/debug/ || echo "Directory not found"
          exit 1
        fi
        
        # Copy module files
        cp -rf module/* output/

        # Remove unwanted files immediately after copying
        rm -f output/pack.py
        rm -f output/Update.json
        rm -f output/format_scripts.sh
        
        # Verify unwanted files were removed
        if [ -f "output/pack.py" ]; then
          echo "⚠️ Warning: pack.py still exists in output directory"
          ls -la output/pack.py
        else
          echo "✅ pack.py successfully removed"
        fi
        
        if [ -f "output/Update.json" ]; then
          echo "⚠️ Warning: Update.json still exists in output directory"
          ls -la output/Update.json
        else
          echo "✅ Update.json successfully removed"
        fi
        
        if [ -f "output/format_scripts.sh" ]; then
          echo "⚠️ Warning: format_scripts.sh still exists in output directory"
          ls -la output/format_scripts.sh
        else
          echo "✅ format_scripts.sh successfully removed"
        fi
        
        # Verify module files were copied
        if [ ! -d "output" ] || [ ! "$(ls -A output)" ]; then
          echo "❌ Failed to copy module files to output"
          echo "📁 Available files in module/:"
          ls -la module/ || echo "Module directory not found"
          exit 1
        fi
        
        # Copy the binary and overwrite the placeholder
        cp -f target/aarch64-linux-android/debug/gpugovernor output/bin/gpugovernor
        chmod +x output/bin/gpugovernor
        
        # Verify the final structure
        echo "📦 Debug module files prepared:"
        ls -la output/
        ls -la output/bin/
        echo "Binary size: $(stat -c%s output/bin/gpugovernor) bytes"
        
        # Final verification before upload
        file_count=$(find output -type f | wc -l)
        if [ "$file_count" -eq 0 ]; then
          echo "❌ No files found in output directory!"
          exit 1
        fi
        echo "✅ Found $file_count files ready for upload"
        
    - name: Debug artifact structure
      run: |
        echo "🔍 Verifying artifact structure before upload:"
        echo "Current directory: $(pwd)"
        echo "output exists: $(test -d output && echo 'YES' || echo 'NO')"
        
        if [ -d "output" ]; then
          echo "Contents of output:"
          find output -type f | head -20
          total_files=$(find output -type f | wc -l)
          echo "Total files in output: $total_files"
          
          if [ "$total_files" -eq 0 ]; then
            echo "❌ ERROR: No files found in output!"
            echo "This will cause the artifact upload to fail."
            exit 1
          fi
        else
          echo "❌ ERROR: output directory not found!"
          echo "Available directories:"
          ls -la
          echo "This will cause the artifact upload to fail."
          exit 1
        fi
        
    - name: Upload debug artifact
      uses: actions/upload-artifact@v4
      with:
        name: Mediatek_Mali_GPU_Governor-debug-${{ github.run_number }}
        path: output
        if-no-files-found: error
        retention-days: 30

    - name: Post-upload verification (debug)
      if: failure()
      run: |
        echo "🔍 Post-upload failure diagnostics:"
        echo "Current working directory: $(pwd)"
        echo "Files in current directory:"
        ls -la
        echo ""
        echo "output directory status:"
        if [ -d "output" ]; then
          echo "Directory exists. Contents:"
          find output -type f | head -10
          echo "Total files: $(find output -type f | wc -l)"
        else
          echo "Directory does not exist!"
        fi

  build-release:
    name: Build Module (release)
    runs-on: ubuntu-latest
    needs: [format-and-check, version-sync, test]
    if: github.event_name != 'workflow_dispatch' || github.event.inputs.build_type == 'release' || github.event.inputs.build_type == 'both' || github.event.inputs.build_type == ''

    # 添加超时限制，防止缓存问题导致的无限等待
    timeout-minutes: 45
        
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        submodules: recursive
        
    - name: Setup Rust
      uses: dtolnay/rust-toolchain@stable
      with:
        targets: aarch64-linux-android

    - name: Cache Rust toolchain
      uses: actions/cache@v4
      with:
        path: |
          ~/.rustup
          ~/.cargo/bin
        key: ${{ runner.os }}-rust-toolchain-build-${{ hashFiles('rust-toolchain.toml', 'Cargo.toml') }}
        restore-keys: |
          ${{ runner.os }}-rust-toolchain-

    - name: Cache cargo-ndk
      uses: actions/cache@v4
      id: cache-cargo-ndk-build
      with:
        path: ~/.cargo/bin/cargo-ndk
        key: ${{ runner.os }}-cargo-ndk-${{ hashFiles('Cargo.toml') }}
        
    - name: Install cargo-ndk
      if: steps.cache-cargo-ndk-build.outputs.cache-hit != 'true'
      run: cargo install cargo-ndk --force

    - name: Install system dependencies for bindgen (always install for reliability)
      run: |
        echo "📦 Installing bindgen dependencies for release build job..."
        
        # 更新包列表
        sudo apt-get update -qq
        
        # 安装必需的clang和libclang依赖
        sudo apt-get install -y --no-install-recommends \
          clang-15 \
          libclang-15-dev \
          llvm-15-dev \
          clang \
          libclang-dev \
          llvm-dev
        
        # 创建多个版本的符号链接以确保兼容性
        sudo ln -sf /usr/bin/clang-15 /usr/local/bin/clang || true
        sudo ln -sf /usr/bin/clang /usr/local/bin/clang || true
        
        # 查找并设置libclang路径
        for libclang_path in /usr/lib/llvm-15/lib /usr/lib/llvm-14/lib /usr/lib/x86_64-linux-gnu; do
          if [ -f "$libclang_path/libclang.so.1" ] || [ -f "$libclang_path/libclang.so" ]; then
            sudo ln -sf "$libclang_path/libclang.so"* /usr/local/lib/libclang.so || true
            echo "Found libclang at: $libclang_path"
            break
          fi
        done
        
        echo "✅ Bindgen dependencies installed for release build"
        
    - name: Setup libclang environment for release build
      run: |
        # 查找可用的libclang路径
        FOUND_LIBCLANG_PATH=""
        for path in /usr/lib/llvm-15/lib /usr/lib/llvm-14/lib /usr/lib/x86_64-linux-gnu; do
          if [ -f "$path/libclang.so.1" ] || [ -f "$path/libclang.so" ]; then
            FOUND_LIBCLANG_PATH="$path"
            echo "Found libclang at: $path"
            break
          fi
        done
        
        if [ -z "$FOUND_LIBCLANG_PATH" ]; then
          echo "❌ libclang not found in expected locations"
          echo "Searching for libclang in system..."
          find /usr -name "libclang.so*" 2>/dev/null | head -5
          exit 1
        fi
        
        # 设置环境变量
        echo "LIBCLANG_PATH=$FOUND_LIBCLANG_PATH" >> $GITHUB_ENV
        echo "CLANG_PATH=/usr/bin/clang" >> $GITHUB_ENV
        
        # 查找clang include路径
        CLANG_INCLUDE_PATH=""
        for path in /usr/lib/llvm-15/lib/clang/15.*/include /usr/lib/llvm-14/lib/clang/14.*/include /usr/lib/clang/*/include; do
          if [ -d "$path" ]; then
            CLANG_INCLUDE_PATH="$path"
            break
          fi
        done
        
        if [ -n "$CLANG_INCLUDE_PATH" ]; then
          echo "BINDGEN_EXTRA_CLANG_ARGS=-I$CLANG_INCLUDE_PATH" >> $GITHUB_ENV
        fi
        
        echo "🔍 Release build libclang environment:"
        echo "LIBCLANG_PATH: $FOUND_LIBCLANG_PATH"
        echo "CLANG_PATH: /usr/bin/clang"
        echo "CLANG_INCLUDE_PATH: $CLANG_INCLUDE_PATH"
        
        # 验证clang工作正常
        clang --version | head -1

    - name: Create Linux-specific Cargo config for release build
      run: |
        # 创建专门用于 Linux CI 的 cargo 配置
        mkdir -p .cargo
        cat > .cargo/config-linux.toml << 'EOF'
        [env]
        # 设置 bindgen 使用的 libclang 路径（从环境变量中读取）
        LIBCLANG_PATH = { value = "$LIBCLANG_PATH", relative = false }
        
        # 设置 clang 可执行文件路径
        CLANG_PATH = { value = "/usr/bin/clang", relative = false }
        
        [target.aarch64-linux-android]
        linker = "aarch64-linux-android33-clang"
        
        [build]
        target = "aarch64-linux-android"
        EOF
        
        # 备份原有的配置文件
        if [ -f ".cargo/config.toml" ]; then
          mv .cargo/config.toml .cargo/config-windows.toml
        fi
        
        # 使用 Linux 配置
        mv .cargo/config-linux.toml .cargo/config.toml
        
        echo "✅ Created Linux-specific Cargo configuration for release"
        cat .cargo/config.toml
      
    - name: Setup Android NDK
      uses: nttld/setup-ndk@v1
      id: setup-ndk
      with:
        ndk-version: r28b

    # 暂时禁用 NDK 缓存避免大小限制问题 - Build Job
    # - name: Cache NDK
    #   uses: actions/cache@v4
    #   with:
    #     path: ${{ steps.setup-ndk.outputs.ndk-path }}
    #     key: ${{ runner.os }}-ndk-r28b
    #     restore-keys: |
    #       ${{ runner.os }}-ndk-
        
    - name: Cache cargo dependencies (release)
      uses: actions/cache@v4
      with:
        path: |
          ~/.cargo/registry
          ~/.cargo/git
        key: ${{ runner.os }}-build-release-cargo-deps-${{ hashFiles('**/Cargo.lock') }}
        restore-keys: |
          ${{ runner.os }}-build-cargo-deps-
          ${{ runner.os }}-cargo-deps-

    - name: Clean target directory (avoid cache size issues)
      run: |
        # Remove old target files to prevent cache bloat
        if [ -d "target" ]; then
          find target -name "*.rlib" -type f -delete 2>/dev/null || true
          find target -name "*.rmeta" -type f -delete 2>/dev/null || true
          find target -name "incremental" -type d -exec rm -rf {} + 2>/dev/null || true
          echo "🧹 Cleaned target directory"
        fi
          
    - name: Build release version
      env:
        ANDROID_NDK_HOME: ${{ steps.setup-ndk.outputs.ndk-path }}
        ANDROID_NDK_ROOT: ${{ steps.setup-ndk.outputs.ndk-path }}
        NDK_HOME: ${{ steps.setup-ndk.outputs.ndk-path }}
        CC_aarch64_linux_android: ${{ steps.setup-ndk.outputs.ndk-path }}/toolchains/llvm/prebuilt/linux-x86_64/bin/aarch64-linux-android33-clang
        CXX_aarch64_linux_android: ${{ steps.setup-ndk.outputs.ndk-path }}/toolchains/llvm/prebuilt/linux-x86_64/bin/aarch64-linux-android33-clang++
        AR_aarch64_linux_android: ${{ steps.setup-ndk.outputs.ndk-path }}/toolchains/llvm/prebuilt/linux-x86_64/bin/llvm-ar
        RANLIB_aarch64_linux_android: ${{ steps.setup-ndk.outputs.ndk-path }}/toolchains/llvm/prebuilt/linux-x86_64/bin/llvm-ranlib
        CARGO_TARGET_AARCH64_LINUX_ANDROID_LINKER: ${{ steps.setup-ndk.outputs.ndk-path }}/toolchains/llvm/prebuilt/linux-x86_64/bin/aarch64-linux-android33-clang
      run: |
        echo "🔍 Release build environment verification:"
        echo "NDK Path: $ANDROID_NDK_HOME"
        echo "LibClang Path: $LIBCLANG_PATH"
        echo "Clang Path: $CLANG_PATH"
        
        # 验证必需的环境变量
        if [ -z "$LIBCLANG_PATH" ]; then
          echo "❌ LIBCLANG_PATH not set!"
          exit 1
        fi
        
        if [ ! -f "$LIBCLANG_PATH/libclang.so.1" ] && [ ! -f "$LIBCLANG_PATH/libclang.so" ]; then
          echo "❌ libclang not found at $LIBCLANG_PATH"
          echo "Available files:"
          ls -la "$LIBCLANG_PATH/" | grep clang || echo "No clang files found"
          exit 1
        fi
        
        # 设置Android相关的bindgen参数
        export BINDGEN_EXTRA_CLANG_ARGS="--target=aarch64-linux-android33 --sysroot=${{ steps.setup-ndk.outputs.ndk-path }}/toolchains/llvm/prebuilt/linux-x86_64/sysroot -I${{ steps.setup-ndk.outputs.ndk-path }}/toolchains/llvm/prebuilt/linux-x86_64/sysroot/usr/include -I${{ steps.setup-ndk.outputs.ndk-path }}/toolchains/llvm/prebuilt/linux-x86_64/sysroot/usr/include/aarch64-linux-android $BINDGEN_EXTRA_CLANG_ARGS"
        
        clang --version | head -1
        
        cargo ndk -t arm64-v8a build --release --target aarch64-linux-android
        
        # Verify build success
        if [ ! -f "target/aarch64-linux-android/release/gpugovernor" ]; then
          echo "❌ Build failed - output binary not found"
          echo "📁 Checking target directory structure:"
          find target -name "gpugovernor" -type f 2>/dev/null || echo "No gpugovernor binary found anywhere"
          exit 1
        fi
        
        echo "✅ Release build completed successfully"
        ls -la target/aarch64-linux-android/release/gpugovernor
        
    - name: Package release module
      run: |
        # Pre-flight checks
        echo "🔍 Pre-flight checks:"
        echo "module directory exists: $(test -d module && echo 'YES' || echo 'NO')"
        echo "module/bin directory exists: $(test -d module/bin && echo 'YES' || echo 'NO')"
        
        if [ ! -d "module" ]; then
          echo "❌ Error: module directory not found!"
          ls -la
          exit 1
        fi
        
        if [ ! -d "module/bin" ]; then
          echo "❌ Error: module/bin directory not found!"
          ls -la module/
          exit 1
        fi
        
        # Create output directory
        mkdir -p output
        
        # Verify the build output exists
        if [ ! -f "target/aarch64-linux-android/release/gpugovernor" ]; then
          echo "❌ Build output not found: target/aarch64-linux-android/release/gpugovernor"
          echo "📁 Available files in target/aarch64-linux-android/release/:"
          ls -la target/aarch64-linux-android/release/ || echo "Directory not found"
          exit 1
        fi
        
        # Copy module files
        cp -rf module/* output/
        
        # Remove unwanted files immediately after copying
        rm -f output/pack.py
        rm -f output/Update.json
        rm -f output/format_scripts.sh
        
        # Verify unwanted files were removed
        if [ -f "output/pack.py" ]; then
          echo "⚠️ Warning: pack.py still exists in output directory"
          ls -la output/pack.py
        else
          echo "✅ pack.py successfully removed"
        fi
        
        if [ -f "output/Update.json" ]; then
          echo "⚠️ Warning: Update.json still exists in output directory"
          ls -la output/Update.json
        else
          echo "✅ Update.json successfully removed"
        fi
        
        if [ -f "output/format_scripts.sh" ]; then
          echo "⚠️ Warning: format_scripts.sh still exists in output directory"
          ls -la output/format_scripts.sh
        else
          echo "✅ format_scripts.sh successfully removed"
        fi
        
        # Verify module files were copied
        if [ ! -d "output" ] || [ ! "$(ls -A output)" ]; then
          echo "❌ Failed to copy module files to output"
          echo "📁 Available files in module/:"
          ls -la module/ || echo "Module directory not found"
          exit 1
        fi
        
        # Copy the binary and overwrite the placeholder
        cp -f target/aarch64-linux-android/release/gpugovernor output/bin/gpugovernor
        chmod +x output/bin/gpugovernor
        
        # Strip the binary
        ${{ steps.setup-ndk.outputs.ndk-path }}/toolchains/llvm/prebuilt/linux-x86_64/bin/llvm-strip output/bin/gpugovernor
        
        # Verify the final structure
        echo "📦 Release module files prepared:"
        ls -la output/
        ls -la output/bin/
        echo "Binary size: $(stat -c%s output/bin/gpugovernor) bytes"
        
        # Final verification before upload
        file_count=$(find output -type f | wc -l)
        if [ "$file_count" -eq 0 ]; then
          echo "❌ No files found in output directory!"
          exit 1
        fi
        echo "✅ Found $file_count files ready for upload"
        
    - name: Debug artifact structure
      run: |
        echo "🔍 Verifying artifact structure before upload:"
        echo "Current directory: $(pwd)"
        echo "output exists: $(test -d output && echo 'YES' || echo 'NO')"
        
        if [ -d "output" ]; then
          echo "Contents of output:"
          find output -type f | head -20
          total_files=$(find output -type f | wc -l)
          echo "Total files in output: $total_files"
          
          if [ "$total_files" -eq 0 ]; then
            echo "❌ ERROR: No files found in output!"
            echo "This will cause the artifact upload to fail."
            exit 1
          fi
        else
          echo "❌ ERROR: output directory not found!"
          echo "Available directories:"
          ls -la
          echo "This will cause the artifact upload to fail."
          exit 1
        fi
        
    - name: Upload release artifact
      uses: actions/upload-artifact@v4
      with:
        name: Mediatek_Mali_GPU_Governor-release-${{ github.run_number }}
        path: output
        if-no-files-found: error
        retention-days: 30

    - name: Post-upload verification (release)
      if: failure()
      run: |
        echo "🔍 Post-upload failure diagnostics:"
        echo "Current working directory: $(pwd)"
        echo "Files in current directory:"
        ls -la
        echo ""
        echo "output directory status:"
        if [ -d "output" ]; then
          echo "Directory exists. Contents:"
          find output -type f | head -10
          echo "Total files: $(find output -type f | wc -l)"
        else
          echo "Directory does not exist!"
        fi

  telegram-notify:
    name: Send to Telegram
    runs-on: ubuntu-latest
    needs: [build-debug, build-release]
    if: always() && (needs.build-debug.result == 'success' || needs.build-release.result == 'success')
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        submodules: recursive

    - name: Setup Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.x'

    - name: Download debug artifact
      if: needs.build-debug.result == 'success'
      uses: actions/download-artifact@v4
      with:
        name: Mediatek_Mali_GPU_Governor-debug-${{ github.run_number }}
        path: ./artifacts/debug/

    - name: Download release artifact
      if: needs.build-release.result == 'success'
      uses: actions/download-artifact@v4
      with:
        name: Mediatek_Mali_GPU_Governor-release-${{ github.run_number }}
        path: ./artifacts/release/

    - name: Prepare files for upload
      run: |
        echo "📦 Preparing files for Telegram upload..."
        
        # Create upload directory
        mkdir -p upload
        
        # Check and prepare debug build
        if [ -d "./artifacts/debug" ] && [ "$(ls -A ./artifacts/debug)" ]; then
          echo "✅ Debug artifacts found"
          cd ./artifacts/debug
          zip -r ../../upload/Mediatek_Mali_GPU_Governor-debug-${{ github.run_number }}.zip .
          cd ../..
        fi
        
        # Check and prepare release build
        if [ -d "./artifacts/release" ] && [ "$(ls -A ./artifacts/release)" ]; then
          echo "✅ Release artifacts found"
          cd ./artifacts/release
          zip -r ../../upload/Mediatek_Mali_GPU_Governor-release-${{ github.run_number }}.zip .
          cd ../..
        fi
        
        echo "📁 Files prepared for upload:"
        ls -la upload/

    - name: Send to Telegram
      env:
        BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
        CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
      run: |
        # Get version info
        CARGO_VERSION=$(grep '^version = ' Cargo.toml | sed 's/version = "//' | sed 's/"//')
        
        # Prepare commit message
        COMMIT_MESSAGE="🚀 **Mediatek Mali GPU Governor Build #${{ github.run_number }}**

        📋 **Build Info:**
        Version: \`v${CARGO_VERSION}\`
        Commit: \`${{ github.sha }}\`
        Branch: \`${{ github.ref_name }}\`
        
        📝 **Commit Message:**
        \`\`\`
        ${{ github.event.head_commit.message }}
        \`\`\`
        by \`${{ github.event.head_commit.author.name }}\`
        
        🔗 [View Workflow](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})"
        
        # Escape special characters for MarkdownV2
        ESCAPED=$(python3 -c 'import sys, re; msg = sys.argv[1]; msg = re.sub(r"([_*\[\]()~`>#+\-=|{}.!])", r"\\\1", msg); msg = msg.replace("\n", "\\n"); print(msg)' "$COMMIT_MESSAGE")
        
        # Send files to Telegram
        cd upload
        for file in *.zip; do
          if [ -f "$file" ]; then
            echo "📤 Uploading: $file"
            curl -v "https://api.telegram.org/bot${BOT_TOKEN}/sendDocument" \
                 -F "chat_id=${CHAT_ID}" \
                 -F "message_thread_id=15" \
                 -F "document=@${file}" \
                 -F "parse_mode=MarkdownV2" \
                 -F "caption=${ESCAPED}"
          fi
        done

  cleanup:
    name: Cache Cleanup (Optional)
    runs-on: ubuntu-latest
    if: github.event_name == 'workflow_dispatch' && github.event.inputs.build_type == 'cleanup'
    
    steps:
    - name: Cleanup old cache entries
      run: |
        echo "🧹 Cache cleanup job - manual trigger only"
        echo "This job can be extended to clean up old cache entries if needed"
        echo "Current caches will be automatically managed by GitHub Actions"


